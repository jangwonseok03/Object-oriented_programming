4개의 클래스에서 공통적으로 들어가는 것이 말하기, 먹기, 걷기, 잠자기 총 4가지가 들어가 있기 때문에 계층적으로 볼 때 앞에서 말한 4가지가 기본 클래스가
되어 가장 위에 위치해 있을 것으로 생각된다.
다음으로는 공부하기와 연구하기로 나눌 수 있기 때문에 이것을 나누면 기본 클래스를 상속받아서 만들어지는 파생 클래스인 student클래스와 Researcher클래스가 
기본 클래스 밑에서 둘이 같은 위치에 공부하기와 연구하기로 나누어져 있을 것이다.
마지막으로는 일하기와 가르치기인데 일하기가 들어가 있는 StudentWorker클래스는 공부하기도 들어가 있기 때문에 Student클래스를 상속받아서 만들어질 것이다. 
그래서 일하기는 공부하기 밑에 위치해있을 것이다.
가르치기가 들어있는 Professor클래스는 연구하기도 들어있기 때문에 Researcher클래스를 상속받아서 만들어질 것이다. 그래서 가르치기는 연구하기 밑에 위치해 
있을 것이라고 생각한다.
정리를 하면 가장 위에 말하기, 먹기, 걷기, 잠자기가 들어있는 기본 클래스가 위치해있을 것이고 그 밑에 파생 클래스인 student클래스(공부하기)와 
Researcher클래스(연구하기)가 같은 선상에 위치해 있을 것이고 student클래스(공부하기) 밑으로 파생된 클래스인 StudentWorker클래스(일하기)가 위치해 있을 
것이고 Researcher클래스(연구하기) 밑으로 파생된 클래스인 Professor클래스(가르치기)가 위치해 있을 것이라고 생각한다.

예제 8-1 
기본 클래스인 Point클래스를 작성하는데는 큰 문제 없이 작성을 했고 파생클래스인 ColorPoint클래스가 Point클래스를 상속받도록 
class ColorPoint:public Point를 작성해서 상속받을 수 있도록 하였고 ColorPoint클래스 안에 어떤 것이 들어가야하는지를 몰라서 그 부분은 작성하는데 
ppt를 조금 보고 코드를 작성하여 돌려봤더니 잘 돌아갔다.

업 캐스팅:
파생클래스의 포인터가 기본 클래스의 포인터에 치환이 되는 것을 말한다.
다운캐스팅:
기본 클래스의 포인터가 파생클래스의 포인터에 치환 되는 것인데 다운캐스팅에서는 강제적으로 타입을 변환 시켜주는 것이 필요하다. 그 이유는 기본 클래스의
포인터를 파생 클래스의 포인터에 치환을 하는데 어떤 파생클래스인지를 정확하게 해줘야 하기 때문에 강제로 타입변환이 필요한 것이다. 업 캐스팅에서는 
상관이 없는 이유는 부모클래스(기본 클래스)는 하나이기 때문에 상관 없다.

예제 8-2
먼저 ColorPoint 클래스에서 x 및 y는 Point 클래스의 protected 멤버이므로 파생 클래스인 ColorPoint에서 직접 접근할 수 없기 때문에 오류가 난다.
다음은 equals 함수의 매개변수로 ColorPoint p를 받아들이지만, 함수 내부에서 p 객체를 사용하는 경우 x 및 y에 접근할 때 p.x 및 p.y를 사용하며, 이는 
ColorPoint 클래스의 protected 멤버이므로 직접 접근할 수 없기 때문에 오류가 난다.
마지막으로 equals 함수 내에서 color에 접근할 때 p.color를 사용하고 있지만, ColorPoint 클래스의 private 멤버인 color를 직접 접근할 수 없기 때문에 
오류가 발생한다.
