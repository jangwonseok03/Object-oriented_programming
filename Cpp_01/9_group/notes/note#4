포인터에 대한 이야기
A. 포인터는 어떠한 객체의 주소 값을 받아서 그 주소 값을 지정해서 저장해주고 함수를 호출하면 저장되어 있는 주소 값을 통해 값을 나타내주는 역할을 하는 것이 포인터가 하는 역할인 것 
같다고 생각한다.
B. 포인터에서 가장 중요하게 생각해야 할 것은 객체의 주소 값을 저장해준다는 것 같다.

예제 4-2
먼저 Cirlce 클래스를 만들고 Circle 클래스 안에서 생성자를 선언해줘야 하는게 중요하다고 생각해서 생성자를 선언하였고 또 이 클래스에서 값을 할당받아 면적을 계산할 수 있도록 
해야할 것 같아서 그렇게 만들었고 코드는 아래와 같았다.
class Circle {
int radius;
public:
Circle() { radius = 1; }
Circle(int r) { radius = r; }
void setRadius(int r) { radius = r; }
double getArea();
};
double Circle::getArea() {
return 3.14*radius*radius;
}
다음으로 Circle 객체 배열을 생성해주고 배열 3가지를 만들어주었다. 그렇게 한 다음 배열의 각 원소들에 값을 할당해주고 배열의 각 원소 객체의 멤버에 접근하여 면적 값을 출력해주도록 
만들었다.
그다음으로는 객체에 대한 포인터를 선언해주고 포인터에 Circle 배열 객체 주소를 저장시키게 해두고 면적 값을 출력시키는 단계에서 포인터에 주소를 호출시켜서 값을 출력하도록 만들었다.
그리고 마지막으로 p++을 통해 배열의 값을 하나씩 추가하여 Circle0, 1, 2의 면적이 출력 될 수 있게 만들었고 실행해보니 정상 작동하였다.
코드를 작성할 때 포인터에 무엇을 할당해야하는지와 클래스 안에 생성자를 선언해줘야하는 부분에서 조금 어려움이 있어서 그 부분은 ppt를 살짝 참고하였다.
그래서 최종적으로 완성한 코드는 아래와 같다.
#include <iostream>
using namespace std;
class Circle {
int radius;
public:
Circle() { radius = 1; }
Circle(int r) { radius = r; }
void setRadius(int r) { radius = r; }
double getArea();
};
double Circle::getArea() {
return 3.14*radius*radius;
}
int main() {
Circle circleArray[3];
circleArray[0].setRadius(10); 
circleArray[1].setRadius(20);
circleArray[2].setRadius(30);
for(int i=0; i<3; i++) 
cout << "Circle " << i << "의 면적은 " << circleArray[i].getArea() << endl;
Circle *p; 
p = circleArray; 
for(int i=0; i<3; i++) { 
cout << "Circle " << i << "의 면적은 " << p->getArea() << endl;
p++; 
}
}

배열의 동적 할당 및 반환
포인터를 선언하고 포인터에 5의 크기만큼의 배열을 할당하고 각 배열에 0부터 4까지 값을 할당받고 마지막에 delete를 한 후에 포인터는 살아있지만 포인터가 가르키는 곳에 접근하지 않게 된다.
